; ==============================================================================
; MIA Synchronous Bus Interface PIO Program
; ==============================================================================
;
; This PIO program implements the synchronous bus protocol for the MIA
; (Multifunction Interface Adapter) interfacing with the W65C02S6TPG-14 CPU.
;
; The MIA generates the PHI2 clock signal and operates synchronously with it,
; sampling bus signals at precise times to avoid reacting to transient signals
; during address/control line settling periods.
;
; TIMING REFERENCE (1 MHz operation, 1000ns cycle):
; ===================================================
;   0ns   - PHI2 falls (cycle start)
;   40ns  - Address valid (tADS)
;   60ns  - MIA samples address (40ns + 50% margin)
;   200ns - MIA samples CS (after address mapping logic)
;   500ns - PHI2 rises
;   530ns - MIA samples R/W and OE (30ns after PHI2 high)
;   540ns - Write data valid (tMDS)
;   985ns - Read data deadline (15ns before PHI2 falls)
;   1000ns- PHI2 falls (CPU samples data)
;   1015ns- Read data hold complete (tDHR)
;
; GPIO PIN ASSIGNMENTS:
; =====================
;   GPIO 0-7   : Address bus A0-A7 (input)
;   GPIO 8-15  : Data bus D0-D7 (bidirectional)
;   GPIO 18    : WE - Write Enable (input, active low)
;   GPIO 19    : OE - Output Enable (input, active low)
;   GPIO 21    : IO0_CS - Chip Select for indexed interface (input, active low)
;   GPIO 28    : PHI2 - Clock output (generated by PWM, can be read back)
;
; Note: R/W signal is derived from WE signal (R/W = !WE for 6502)
;
; PIO CONFIGURATION:
; ==================
;   IN pins base  : GPIO 0 (address bus A0-A7)
;   OUT pins base : GPIO 8 (data bus D0-D7)
;   SET pins base : GPIO 8 (data bus direction control)
;   JMP pin       : GPIO 21 (IO0_CS chip select)
;   Sideset pins  : None
;   Clock divider : 1.0 (125 MHz PIO clock, 8ns per instruction)
;
; HYBRID PIO + C APPROACH:
; ========================
; This implementation uses a hybrid approach where:
; - PIO handles precise timing of PHI2, address, and CS sampling
; - PIO triggers IRQ to notify C code when CS is active at 200ns
; - C code waits for PHI2 to rise, then reads OE and WE at 530ns (when valid)
; - C code determines operation type and prepares response
; - C code pushes control byte + data (if READ) to TX FIFO
; - PIO blocks waiting for C response, then handles data bus operations
;
; TIMING STRATEGY:
; ================
; The key insight is that OE and WE signals are only valid 30ns after PHI2 rises
; (at 530ns). Therefore:
; 1. PIO triggers C code at 200ns (when CS is active)
; 2. C code speculatively prepares READ data during 200-530ns window
; 3. C code waits for PHI2 to rise (500ns)
; 4. C code reads OE/WE at 530ns (now valid!)
; 5. C code determines operation and pushes response to TX FIFO
; 6. PIO pulls response and acts accordingly
;
; This avoids reading OE/WE too early (when they're still settling) and gives
; C code the full 200-530ns window for speculative data preparation.
;
; FIFO PROTOCOL:
; ==============
;   RX FIFO (PIO → CPU):
;     - Address byte (8 bits from GPIO 0-7, pushed at 60ns)
;     - Data byte (for WRITE operations only, pushed at 1000ns)
;
;   TX FIFO (CPU → PIO):
;     - Control byte: 0x00 = NOP, 0x01 = READ, 0x02 = WRITE
;     - Data byte (for READ operations only, data to drive on bus)
;
; OPERATION:
; ==========
;   PIO Side:
;   1. Wait for PHI2 falling edge (cycle start at 0ns)
;   2. Delay 60ns, sample address bus → push to RX FIFO
;   3. Delay to 200ns, sample CS
;   4. If CS inactive, return to step 1
;   5. Trigger IRQ 0 to notify C code
;   6. Block waiting for control byte from TX FIFO
;   7. If control = NOP: return to step 1
;   8. If control = READ: pull data, drive bus, hold for tDHR
;   9. If control = WRITE: wait for PHI2 fall, latch data, push to RX FIFO
;   10. Return to step 1
;
;   C Code Side (IRQ handler):
;   1. Read address from RX FIFO (triggered at 200ns)
;   2. Speculatively prepare READ data (200-400ns)
;   3. Wait for PHI2 to rise (poll GPIO 28 until high)
;   4. Wait 30ns for OE/WE to settle (530ns mark)
;   5. Read OE pin (GPIO 19) - now valid!
;   6. Read WE pin (GPIO 18) - now valid!
;   7. Determine operation type (READ/WRITE/NOP)
;   8. Push control byte to TX FIFO
;   9. If READ: push data byte to TX FIFO
;   10. Exit IRQ handler
;
; ==============================================================================

.program bus_sync

.define public PHI2_PIN     28      ; Clock signal (generated by MIA)
.define public CS_PIN       21      ; Chip select (active low)
.define public OE_PIN       19      ; Output enable (active low)
.define public WE_PIN       18      ; Write enable (active low, R/W = !WE)

.define public ADDR_BASE    0       ; Address bus base (GPIO 0-7)
.define public DATA_BASE    8       ; Data bus base (GPIO 8-15)

; Control byte values (from C code via TX FIFO)
.define public CTRL_NOP     0       ; No operation (CS inactive or OE inactive)
.define public CTRL_READ    1       ; READ operation
.define public CTRL_WRITE   2       ; WRITE operation

; Timing constants (in PIO instructions at 125 MHz, 8ns per instruction)
.define DELAY_TO_60NS       7       ; 7 instructions × 8ns = 56ns ≈ 60ns
.define DELAY_60_TO_200NS   17      ; 17 instructions × 8ns = 136ns (60ns + 136ns = 196ns ≈ 200ns)
.define DELAY_TO_30NS       3       ; 3 instructions × 8ns = 24ns ≈ 30ns
.define DELAY_TDHR          2       ; 2 instructions × 8ns = 16ns ≈ 15ns (tDHR)

; ==============================================================================
; Main synchronous bus protocol state machine
; ==============================================================================

public entry_point:
wait_cycle_start:
    ; Wait for PHI2 falling edge (cycle start at 0ns)
    ; This is the beginning of a new bus cycle
    wait 0 gpio PHI2_PIN                ; Wait for PHI2 = LOW (falling edge)
    
    ; Delay 60ns for address to settle (tADS = 40ns + 50% margin)
    ; At 125 MHz PIO clock: 7 instructions × 8ns = 56ns ≈ 60ns
    nop [DELAY_TO_60NS - 1]             ; Delay to 60ns mark
    
sample_address:
    ; Sample address bus at 60ns (after address settling time)
    ; Read 8 bits from GPIO 0-7 (address bus A0-A7)
    in pins, 8                          ; Read address → ISR
    push noblock                        ; Push address to RX FIFO (non-blocking)
    
    ; Delay from 60ns to 200ns for CS to settle
    ; Need additional 140ns: 17 instructions × 8ns = 136ns ≈ 140ns
    nop [DELAY_60_TO_200NS - 1]         ; Delay to 200ns mark
    
sample_cs:
    ; Sample CS at 200ns (after address mapping logic settles)
    ; CS is active low, so we check if it's LOW (selected)
    ; JMP pin is configured to GPIO 21 (IO0_CS)
    jmp pin wait_cycle_start            ; If CS = HIGH (not selected), restart
    
    ; CS is active (LOW), we are selected
    ; Trigger interrupt to notify C code at 200ns
    ; C code will:
    ;   1. Read address from RX FIFO
    ;   2. Speculatively prepare READ data (200-530ns window)
    ;   3. Wait for PHI2 to rise (poll GPIO 28)
    ;   4. Wait 30ns for OE/WE to settle (530ns mark)
    ;   5. Read OE and WE pins (now valid!)
    ;   6. Determine operation type (READ/WRITE/NOP)
    ;   7. Push control byte (and data if READ) to TX FIFO
    irq set 0                           ; Set IRQ 0 to notify C code
    
    ; Now wait for C code to provide response
    ; C code has from 200ns to ~550ns to respond
    ; This gives C code 350ns to:
    ;   - Decode address and prepare data (200-400ns)
    ;   - Wait for PHI2 high (400-500ns)
    ;   - Read OE/WE at 530ns
    ;   - Push response (530-550ns)
    
wait_for_c_response:
    ; Block waiting for control byte from C code
    ; C will push this after reading OE/WE at 530ns
    pull block                          ; Pull control byte from TX FIFO (blocking)
    out x, 8                            ; Move control byte to X register
    
    ; Check control byte and branch accordingly
    ; Control values: 0 = NOP, 1 = READ, 2 = WRITE
    jmp !x wait_cycle_start             ; If control = 0 (NOP), restart cycle
    
    ; Check if READ (control = 1)
    set y, 1                            ; Set Y = 1 for comparison
    jmp x!=y check_write                ; If X != 1, check if WRITE
    jmp handle_read                     ; X = 1, it's a READ
    
check_write:
    ; Check if WRITE (control = 2)
    set y, 2                            ; Set Y = 2 for comparison
    jmp x!=y wait_cycle_start           ; If X != 2, invalid control, restart
    jmp handle_write                    ; X = 2, it's a WRITE
    
; ==============================================================================
; READ operation handler
; ==============================================================================
handle_read:
    ; READ operation: drive data from TX FIFO onto data bus
    ; Data must be valid by 985ns (15ns before PHI2 falls at 1000ns)
    ; We have from 530ns to 985ns = 455ns to drive data
    
    ; Pull data from TX FIFO (prepared by CPU during 200-530ns window)
    pull block                          ; Pull data from TX FIFO (blocking)
    
    ; Configure data bus (GPIO 8-15) as outputs
    ; Use SET instruction to configure pin directions
    set pindirs, 0xFF                   ; Set D0-D7 as outputs (bits 0-7 = 0xFF)
    
    ; Drive data onto data bus
    out pins, 8                         ; Output 8 bits to GPIO 8-15 (data bus)
    
    ; Data is now being driven
    ; Wait for PHI2 falling edge at 1000ns (CPU samples data)
    wait 0 gpio PHI2_PIN                ; Wait for PHI2 = LOW (falling edge)
    
    ; Hold data for tDHR (15ns after PHI2 falls)
    ; At 125 MHz PIO clock: 2 instructions × 8ns = 16ns ≈ 15ns
    nop [DELAY_TDHR - 1]                ; Delay for tDHR (data hold time)
    
    ; Tri-state data bus (configure as inputs)
    set pindirs, 0x00                   ; Set D0-D7 as inputs (tri-state)
    
    ; Return to wait for next cycle
    jmp wait_cycle_start                ; Return to cycle start
    
; ==============================================================================
; WRITE operation handler
; ==============================================================================
handle_write:
    ; WRITE operation: latch data from data bus
    ; Data is valid from 540ns to 1010ns (tMDS to tDHW)
    ; Best practice: sample on PHI2 falling edge at 1000ns
    
    ; Ensure data bus is configured as inputs (should already be)
    set pindirs, 0x00                   ; Set D0-D7 as inputs
    
    ; Wait for PHI2 falling edge at 1000ns (optimal sampling point)
    wait 0 gpio PHI2_PIN                ; Wait for PHI2 = LOW (falling edge)
    
    ; Latch data from data bus on falling edge
    in pins, 8                          ; Read 8 bits from GPIO 8-15 (data bus)
    push noblock                        ; Push data to RX FIFO (non-blocking)
    
    ; Data hold time (tDHW = 10ns) is guaranteed by CPU
    ; We can immediately return to wait for next cycle
    jmp wait_cycle_start                ; Return to cycle start

; ==============================================================================
; End of PIO program
; ==============================================================================

% c-sdk {
#include "hardware/pio.h"
#include "hardware/gpio.h"

// Helper function to initialize the PIO program
static inline void bus_sync_program_init(PIO pio, uint sm, uint offset) {
    // Get default configuration
    pio_sm_config c = bus_sync_program_get_default_config(offset);
    
    // Configure IN pins (address bus: GPIO 0-7, then data bus: GPIO 8-15)
    // IN base is GPIO 0, but we'll read from different pins at different times
    sm_config_set_in_pins(&c, 0);  // Base at GPIO 0 for address reads
    
    // Configure OUT pins (data bus: GPIO 8-15)
    sm_config_set_out_pins(&c, 8, 8);  // 8 pins starting at GPIO 8
    
    // Configure SET pins (data bus direction: GPIO 8-15)
    sm_config_set_set_pins(&c, 8, 8);  // 8 pins starting at GPIO 8
    
    // Configure JMP pin (chip select: GPIO 21)
    sm_config_set_jmp_pin(&c, 21);  // IO0_CS on GPIO 21
    
    // Configure clock divider (1.0 = 125 MHz, 8ns per instruction)
    sm_config_set_clkdiv(&c, 1.0);
    
    // Configure shift registers
    // IN: shift right, no autopush, 8 bits threshold
    sm_config_set_in_shift(&c, false, false, 8);
    // OUT: shift right, no autopull, 8 bits threshold
    sm_config_set_out_shift(&c, true, false, 8);
    
    // Configure FIFO join (normal mode, separate RX and TX FIFOs)
    sm_config_set_fifo_join(&c, PIO_FIFO_JOIN_NONE);
    
    // Initialize GPIO pins
    // Address bus (GPIO 0-7) as inputs
    for (int i = 0; i < 8; i++) {
        pio_gpio_init(pio, i);
        gpio_set_dir(i, GPIO_IN);
        gpio_pull_up(i);  // Pull-up for stable reads
    }
    
    // Data bus (GPIO 8-15) - will be controlled by PIO SET instruction
    // Initialize as inputs, PIO will change direction as needed
    for (int i = 8; i < 16; i++) {
        pio_gpio_init(pio, i);
        gpio_set_dir(i, GPIO_IN);
    }
    
    // Control signals as inputs (not controlled by PIO, read by C code)
    // CS (GPIO 21) - used as JMP pin by PIO
    gpio_init(21);
    gpio_set_dir(21, GPIO_IN);
    gpio_pull_up(21);  // Pull-up for active-low signal
    
    // OE (GPIO 19) - read by C code
    gpio_init(19);
    gpio_set_dir(19, GPIO_IN);
    gpio_pull_up(19);  // Pull-up for active-low signal
    
    // WE (GPIO 18) - read by C code
    gpio_init(18);
    gpio_set_dir(18, GPIO_IN);
    gpio_pull_up(18);  // Pull-up for active-low signal
    
    // PHI2 clock (GPIO 28) - generated by PWM, but PIO can read it
    // Note: PWM configuration is done separately in clock_control module
    gpio_init(28);
    gpio_set_dir(28, GPIO_IN);  // PIO reads clock state
    
    // Load configuration and jump to entry point
    pio_sm_init(pio, sm, offset + bus_sync_offset_entry_point, &c);
    
    // Enable IRQ 0 for this state machine
    pio_set_irq0_source_enabled(pio, pis_interrupt0, true);
    
    // Start state machine
    pio_sm_set_enabled(pio, sm, true);
