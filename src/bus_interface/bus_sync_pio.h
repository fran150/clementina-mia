/**
 * MIA Synchronous Bus Interface PIO Integration
 * 
 * This module provides the C interface for the PIO-based synchronous bus protocol.
 * The PIO handles precise timing of signal sampling while C code handles the
 * complex logic of address decoding and data preparation.
 * 
 * SYNCHRONOUS OPERATION STRATEGY:
 * ================================
 * The MIA generates the PHI2 clock and operates synchronously with it, sampling
 * bus signals at precise times to avoid reacting to transient signals during
 * address/control line settling periods.
 * 
 * KEY TIMING INSIGHT:
 * ===================
 * OE and WE signals are only valid 30ns after PHI2 rises (at 530ns). Therefore,
 * C code must wait for PHI2 to rise before reading these signals. The design
 * uses speculative execution to make productive use of the 200-530ns window.
 * 
 * TIMING POINTS (1 MHz operation, 1000ns cycle):
 * ===============================================
 *   0ns   - PHI2 falls (cycle start) - PIO detects falling edge
 *   60ns  - PIO samples address bus (40ns tADS + 50% margin)
 *   200ns - PIO samples CS (after address mapping logic settles)
 *   200ns - PIO triggers IRQ to notify C code
 *   200ns - C code starts, reads address, speculatively prepares READ data
 *   400ns - C code has data ready, waits for PHI2 to rise
 *   500ns - PHI2 rises
 *   530ns - C code reads OE and WE pins (now valid!)
 *   540ns - C code determines operation type
 *   550ns - C code pushes control byte (and data for READ) to TX FIFO
 *   550ns - PIO pulls control byte from TX FIFO
 *   560ns - For READ: PIO pulls data and drives bus
 *   985ns - For READ: Data must be valid (425ns available from 560ns)
 *   1000ns - PHI2 falls - For READ: CPU samples data, For WRITE: PIO latches data
 *   1015ns - For READ: PIO releases bus after tDHR hold time
 * 
 * HYBRID PIO + C ARCHITECTURE:
 * ============================
 * PIO Responsibilities:
 * - Detect PHI2 falling edge (cycle start at 0ns)
 * - Sample address at 60ns → push to RX FIFO
 * - Sample CS at 200ns → trigger IRQ if active
 * - Block waiting for control byte from C code
 * - For READ: pull data, drive bus, hold for tDHR
 * - For WRITE: latch data on PHI2 falling edge, push to RX FIFO
 * 
 * C Code Responsibilities (IRQ handler):
 * - Read address from RX FIFO (triggered at 200ns)
 * - Speculatively prepare READ data (200-400ns)
 * - Wait for PHI2 to rise (poll GPIO 28)
 * - Wait 30ns for OE/WE to settle (530ns mark)
 * - Read OE pin (GPIO 19) - now valid!
 * - Read WE pin (GPIO 18) - now valid!
 * - Determine operation type: NOP (OE inactive), READ, or WRITE
 * - Push control byte to TX FIFO
 * - For READ: push data byte to TX FIFO
 * - For WRITE/NOP: no data byte needed
 * 
 * CONTROL BYTE VALUES:
 * ====================
 * 0x00 - NOP: No operation (CS inactive or OE inactive)
 * 0x01 - READ: Drive data onto bus
 * 0x02 - WRITE: Latch data from bus
 * 
 * FIFO PROTOCOL:
 * ==============
 * RX FIFO (PIO → C):
 *   - Address byte (8 bits, pushed at 60ns)
 *   - Data byte (8 bits, pushed at 1000ns for WRITE operations only)
 * 
 * TX FIFO (C → PIO):
 *   - Control byte (0x00 = NOP, 0x01 = READ, 0x02 = WRITE)
 *   - Data byte (for READ operations only, data to drive on bus)
 * 
 * TIMING BUDGET:
 * ==============
 * Speculative preparation: 200-400ns = 200ns (decode address, fetch data)
 * Wait for PHI2: 400-500ns = 100ns (busy-wait polling)
 * OE/WE check: 530-540ns = 10ns (read pins, determine operation)
 * Response: 540-560ns = 20ns (push control+data to FIFO)
 * PIO drive: 560-985ns = 425ns (drive data for READ operations)
 * 
 * Total C execution: ~360ns (well within 785ns budget)
 * 
 * At 133 MHz ARM core clock:
 * - Speculative prep: ~27 cycles
 * - Wait loop: ~13 cycles
 * - OE/WE check: ~2 cycles
 * - FIFO push: ~3 cycles
 * Total: ~45 cycles = ~340ns
 */

#ifndef BUS_SYNC_PIO_H
#define BUS_SYNC_PIO_H

#include <stdint.h>
#include <stdbool.h>
#include "hardware/pio.h"

// Control byte values for TX FIFO (C → PIO)
#define BUS_CTRL_NOP    0x00    // No operation (OE inactive or CS inactive)
#define BUS_CTRL_READ   0x01    // READ operation - PIO will drive data bus
#define BUS_CTRL_WRITE  0x02    // WRITE operation - PIO will latch data bus

// GPIO pin definitions (must match bus_sync.pio)
#define BUS_PHI2_PIN    28      // Clock signal (generated by MIA, read by PIO)
#define BUS_CS_PIN      21      // Chip select (active low, IO0_CS)
#define BUS_OE_PIN      19      // Output enable (active low)
#define BUS_WE_PIN      18      // Write enable (active low, R/W = !WE)

// PIO configuration
#define BUS_PIO_INSTANCE    pio0    // Use PIO 0
#define BUS_PIO_SM          0       // Use state machine 0
#define BUS_PIO_IRQ         0       // Use IRQ 0

/**
 * Initialize the synchronous bus interface PIO
 * 
 * This function:
 * - Loads the PIO program into PIO memory
 * - Configures the state machine
 * - Sets up GPIO pins
 * - Enables the IRQ handler
 * - Starts the state machine
 * 
 * Must be called after clock_control_init() to ensure PHI2 is running.
 */
void bus_sync_pio_init(void);

/**
 * PIO IRQ handler (called when CS is sampled active at 200ns)
 * 
 * This function implements the speculative execution strategy:
 * 1. Reads address from RX FIFO (triggered at 200ns)
 * 2. Speculatively prepares READ data (assumes READ operation)
 * 3. Waits for PHI2 to rise (polls GPIO 28 until high)
 * 4. Waits 30ns for OE/WE to settle (530ns mark)
 * 5. Reads OE pin (GPIO 19) - now valid!
 * 6. Reads WE pin (GPIO 18) - now valid!
 * 7. Determines actual operation type:
 *    - If OE inactive: NOP
 *    - If OE active + WE inactive: READ (use speculative data)
 *    - If OE active + WE active: WRITE (discard speculative data)
 * 8. Pushes control byte to TX FIFO
 * 9. If READ: pushes data byte to TX FIFO
 * 
 * Timing breakdown:
 * - 200-400ns: Speculative preparation (200ns)
 * - 400-500ns: Wait for PHI2 high (100ns busy-wait)
 * - 530-540ns: Read OE/WE and determine operation (10ns)
 * - 540-560ns: Push response to FIFO (20ns)
 * Total: ~360ns (well within 785ns budget)
 */
void bus_sync_pio_irq_handler(void);

/**
 * Process WRITE data from RX FIFO
 * 
 * After a WRITE operation, the PIO pushes the latched data byte to RX FIFO.
 * This function should be called periodically to process pending WRITE data.
 * 
 * @return true if data was processed, false if FIFO was empty
 */
bool bus_sync_pio_process_write_data(void);

/**
 * Check if PIO is ready for next cycle
 * Useful for debugging and diagnostics
 * 
 * @return true if PIO state machine is running and FIFOs are not stalled
 */
bool bus_sync_pio_is_ready(void);

/**
 * Get PIO statistics for debugging
 * 
 * @param rx_level Pointer to store RX FIFO level (0-8)
 * @param tx_level Pointer to store TX FIFO level (0-8)
 * @param stalled Pointer to store stall status
 */
void bus_sync_pio_get_stats(uint8_t *rx_level, uint8_t *tx_level, bool *stalled);

/**
 * Check for FIFO overflow/underflow conditions
 * 
 * This function checks for error conditions that indicate timing problems:
 * - RX overflow: PIO is pushing data faster than C can consume it
 * - TX underflow: PIO is pulling data faster than C can provide it
 * 
 * When FIFO errors occur, the IRQ handler automatically:
 * - Sets STATUS_MEMORY_ERROR in the device status register
 * - Triggers IRQ_MEMORY_ERROR interrupt (if enabled)
 * - Tri-states the data bus to prevent bus contention
 * - Aborts the current bus cycle
 * 
 * The 6502 can detect these errors by:
 * - Polling DEVICE_STATUS register (0xF0) for STATUS_MEMORY_ERROR bit
 * - Handling IRQ_MEMORY_ERROR interrupt (bit 0 of IRQ_CAUSE)
 * 
 * @param rx_overflow Pointer to store RX FIFO overflow status (true = overflow)
 * @param tx_underflow Pointer to store TX FIFO underflow status (true = underflow)
 */
void bus_sync_pio_check_fifo_errors(bool *rx_overflow, bool *tx_underflow);

#endif // BUS_SYNC_PIO_H
