# Implementation Plan

- [x] 1. Set up project structure and core interfaces
  - Create directory structure for hardware abstraction, indexed memory system, and network components
  - Define GPIO pin mapping constants (GPIO 0-7: address, GPIO 8-15: data, GPIO 18-21,26,28: control)
  - Set up CMake build system for Raspberry Pi Pico 2 W
  - Configure development environment with Pico SDK and TinyUSB
  - _Requirements: All requirements - foundational setup_

- [x] 2. Implement PWM clock generation system
  - Configure Raspberry Pi PWM module on GPIO 28 for clock output
  - Implement frequency control functions for 100 kHz and 1 MHz operation
  - Add software control interface for dynamic frequency adjustment
  - Implement frequency stability monitoring and validation
  - _Requirements: 1.1, 1.2, 1.3, 1.4, 1.5_

- [x] 3. Implement ROM emulation for boot phase
  - Configure GPIO pins for 6502 bus interface (address A0-A7 on GPIO 0-7, data D0-D7 on GPIO 8-15, control signals)
  - Implement reset line control and boot sequence initialization (assert reset for 5+ cycles)
  - Create 6502 bus interface using C code for 100 kHz operation
  - Implement address decoding for $E000-$FFFF range using 8 address lines (A0-A7 on GPIO 0-7, 256-byte space with mirroring)
  - Create minimal 6502 boot loader assembly code (< 100 bytes) with kernel copying loop using addresses $E080/$E081
  - Embed complete kernel binary as C array in MIA firmware
  - Implement two memory-mapped addresses: status ($E080) and data ($E081) within 256-byte ROM space
  - Add automatic kernel pointer advancement on data address reads
  - Implement reset vector response ($FFFC-$FFFD) with boot loader entry address
  - Add PICOHIRAM banking control, clock speed transition to 1 MHz, and indexed interface activation
  - _Requirements: 2.1, 2.2, 2.3, 2.4, 2.5, 2.6, 2.7, 2.8, 2.9, 2.10, 2.11_

- [x] 4. Implement indexed memory system core
  - Create 256-index data structure with current address, default address, limit address, step, and flags
  - Implement index allocation and initialization (system, video, USB, user ranges)
  - Add basic index configuration functions (set address, default, limit, step, flags)
  - Create memory access functions for reading/writing via indexes
  - Add auto-stepping functionality (increment/decrement with configurable step size)
  - Implement wrap-on-limit feature for automatic reset to default when reaching limit address
  - Test: Verify index structure, basic memory access, auto-stepping, and wrap-on-limit
  - _Requirements: 5.5, 6.1, 6.6, 6.7, 6.8, 6.9, 6.10_

- [ ] 5. Implement bus interface foundation
  - [x] 5.1 Create bus interface module structure (bus_interface.h and bus_interface.c)
    - Define register address constants for indexed interface mode ($C000-$C0FF)
    - Define multi-window architecture (Windows A-D) and shared register space
    - Define window detection macros and helper functions
    - Create function prototypes for main entry points (bus_interface_read/write)
    - _Requirements: 5.1, 5.2_
  - [x] 5.2 Implement address decoding logic
    - Create function to decode register offset from address (0-15 for each window)
    - Implement window detection (bits 4-6 determine window: 0=A, 1=B, 2=C, 3=D)
    - Implement shared space detection (bit 7 set: $C080-$C0FF)
    - Add support for 4 active windows plus 4 future windows (E-H)
    - _Requirements: 5.1, 5.2_
  - [x] 5.3 Create window state management structures
    - Define window_state_t structure to track per-window state (active_index, config_field_select)
    - Create global window_state array supporting up to 8 windows (A-H)
    - Implement window state initialization in bus_interface_init()
    - Add helper functions for window state access (get/set active index, config field)
    - _Requirements: 5.5, 6.1_
  - [x] 5.4 Create main dispatcher functions
    - Implement bus_interface_read(address) - main READ entry point with shared register support
    - Implement bus_interface_write(address, data) - main WRITE entry point with shared register support
    - Add switch statement structure for window register routing
    - Add switch statement structure for shared register routing
    - _Requirements: 5.1, 5.2, 5.3_
  - [x] 5.5 Add unit tests for address decoding
    - Test window detection for all windows (A, B, C, D)
    - Test shared space detection ($C080-$C0FF)
    - Test register offset calculation for multi-window architecture
    - Verify boundary conditions between windows and shared space
    - _Requirements: 5.1, 5.2_

- [ ] 6. Implement register handlers - Index selection
  - [x] 6.1 Implement IDX_SELECT read handler
    - Create read_idx_select(window_num) function supporting all windows (A, B, C, D)
    - Return currently selected index for specified window
    - Integrate with indexed_memory_get_window_index()
    - _Requirements: 6.1_
  - [x] 6.2 Implement IDX_SELECT write handler
    - Create write_idx_select(window_num, index) function supporting all windows (A, B, C, D)
    - Update active index selection for specified window
    - Integrate with indexed_memory_set_window_index()
    - _Requirements: 6.1_
  - [x] 6.3 Test index selection operations
    - Test reading selected index for all windows (A, B, C, D)
    - Test changing selected index for all windows
    - Verify window independence across all four windows
    - _Requirements: 6.1_

- [ ] 7. Implement register handlers - Data port
  - [x] 7.1 Implement DATA_PORT read handler
    - Create read_data_port(window_num) function supporting all windows (A, B, C, D)
    - Read byte from currently selected index with auto-stepping
    - Integrate with indexed_memory_read()
    - _Requirements: 6.2_
  - [x] 7.2 Implement DATA_PORT write handler
    - Create write_data_port(window_num, data) function supporting all windows (A, B, C, D)
    - Write byte to currently selected index with auto-stepping
    - Integrate with indexed_memory_write()
    - _Requirements: 6.2_
  - [x] 7.3 Test data port operations
    - Test sequential reads with auto-stepping
    - Test sequential writes with auto-stepping
    - Test with different step sizes and directions
    - Verify wrap-on-limit functionality
    - _Requirements: 6.2, 6.9, 6.10_

- [x] 8. Implement register handlers - Configuration
  - [x] 8.1 Implement CFG_FIELD_SELECT handlers
    - Create read_cfg_field_select(window_b) function
    - Create write_cfg_field_select(window_b, field) function
    - Integrate with indexed_memory_get/set_config_field_select()
    - _Requirements: 6.4_
  - [x] 8.2 Implement CFG_DATA read handler
    - Create read_cfg_data(window_b) function
    - Read selected configuration field from active index
    - Integrate with indexed_memory_get_config_field()
    - _Requirements: 6.5_
  - [x] 8.3 Implement CFG_DATA write handler
    - Create write_cfg_data(window_b, data) function
    - Write to selected configuration field of active index
    - Integrate with indexed_memory_set_config_field()
    - _Requirements: 6.5_
  - [x] 8.4 Test configuration access
    - Test reading all configuration field types (address, default, limit, step, flags)
    - Test writing all configuration field types
    - Test multi-byte field access (24-bit addresses)
    - Verify DMA configuration fields (COPY_SRC_IDX, COPY_DST_IDX, COPY_COUNT)
    - _Requirements: 6.4, 6.5, 6.8_

- [x] 9. Implement shared register handlers - Status and interrupts
  - [x] 9.1 Implement DEVICE_STATUS read handler
    - Create read_device_status() function for shared register at $C0F0
    - Return system status register value
    - Integrate with indexed_memory_get_status()
    - _Requirements: 7.7, 8.4_
  - [x] 9.2 Implement IRQ_CAUSE_LOW handlers
    - Create read_irq_cause_low() function for shared register at $C0F1
    - Create write_irq_cause_low(clear_bits) function with write-1-to-clear logic
    - Integrate with indexed_memory_get/write_irq_cause_low()
    - _Requirements: 8.2, 8.3_
  - [x] 9.3 Implement IRQ_CAUSE_HIGH handlers
    - Create read_irq_cause_high() function for shared register at $C0F2
    - Create write_irq_cause_high(clear_bits) function with write-1-to-clear logic
    - Integrate with indexed_memory_get/write_irq_cause_high()
    - _Requirements: 8.2, 8.3_
  - [x] 9.4 Implement IRQ_MASK handlers
    - Create read_irq_mask_low() function for shared register at $C0F3
    - Create write_irq_mask_low(mask) function
    - Create read_irq_mask_high() function for shared register at $C0F4
    - Create write_irq_mask_high(mask) function
    - _Requirements: 8.3, 8.11_
  - [x] 9.5 Implement IRQ_ENABLE handler
    - Create read_irq_enable() function for shared register at $C0F5
    - Create write_irq_enable(enable) function for global interrupt control
    - _Requirements: 8.4, 8.11_
  - [x] 9.6 Test shared register handling
    - Test device status register reading
    - Test interrupt cause reading (both bytes)
    - Test interrupt mask reading and writing (both bytes)
    - Test global interrupt enable/disable
    - Test write-1-to-clear functionality for individual interrupt bits
    - Verify IRQ line behavior (assert/deassert based on mask and enable)
    - _Requirements: 7.7, 8.2, 8.3, 8.4, 8.8, 8.11, 8.12_

- [ ] 10. Implement register handlers - Commands
  - [ ] 10.1 Implement COMMAND write handler
    - Create write_command(window_b, command) function
    - Route command to indexed_memory_execute_command()
    - Handle command execution and status updates
    - _Requirements: 7.1, 7.2_
  - [ ] 10.2 Test basic commands
    - Test CMD_RESET_INDEX (reset active index to default address)
    - Test CMD_RESET_ALL (reset all indexes)
    - Test CMD_CLEAR_IRQ (clear all pending interrupts)
    - Test CMD_PICO_REINIT (reinitialize system)
    - _Requirements: 7.2, 7.3, 7.6_
  - [ ] 10.3 Test DMA commands
    - Test CMD_COPY_BYTE (single byte copy between indexes)
    - Test CMD_COPY_BLOCK (multi-byte block copy)
    - Verify DMA configuration via CFG_DATA (source, destination, count)
    - Test DMA completion interrupt generation
    - _Requirements: 7.4, 7.5, 7.8_

- [ ] 11. Implement PIO integration for bus timing
  - [ ] 11.1 Design PIO state machine for bus protocol
    - Create PIO program to monitor CS signals (HIRAM_CS on GPIO 20, IO0_CS on GPIO 21)
    - Implement address capture from GPIO 0-7 when CS is active
    - Add R/W signal detection (GPIO 18) to distinguish READ vs WRITE
    - Implement OE signal monitoring (GPIO 19) for bus direction control
    - _Requirements: 5.6, 5.7, 5.8_
  - [ ] 11.2 Implement READ cycle timing in PIO
    - Wait for R/W HIGH to confirm READ operation
    - Configure data bus (GPIO 8-15) as output when OE goes LOW
    - Drive data onto bus with proper timing (valid by 985ns)
    - Hold data for 15ns after PHI2 falls (1000-1015ns) even after OE goes HIGH
    - Tri-state bus after hold period
    - _Requirements: 5.7, 5.8, 5.9_
  - [ ] 11.3 Implement WRITE cycle timing in PIO
    - Wait for R/W LOW to confirm WRITE operation
    - Keep data bus (GPIO 8-15) as input during WRITE
    - Latch data on PHI2 falling edge (1000ns)
    - Pass captured data to C code for processing
    - _Requirements: 5.9_
  - [ ] 11.4 Implement PIO-C communication
    - Set up FIFO communication between PIO and C code
    - PIO sends: operation type (READ/WRITE), address, data (for WRITE)
    - C code sends: data value (for READ)
    - Add interrupt mechanism for operation notification
    - _Requirements: 5.6, 5.7_
  - [ ] 11.5 Integrate PIO with C bus interface handlers
    - Connect PIO interrupt handler to bus_interface_read/write functions
    - Implement speculative preparation during 200-530ns window
    - Add fast path for simple operations (IDX_SELECT, STATUS)
    - Verify timing budgets: 785ns for READ, 470ns for WRITE
    - _Requirements: 5.6, 5.7, 5.8, 5.9, 5.11_
  - [ ] 11.6 Test PIO timing and integration
    - Verify READ cycle timing with logic analyzer
    - Verify WRITE cycle timing with logic analyzer
    - Test back-to-back operations
    - Verify bus contention avoidance (OE signal compliance)
    - Test window priority (Window A takes precedence)
    - _Requirements: 5.6, 5.7, 5.8, 5.9, 5.11_

- [ ] 12. Complete indexed interface end-to-end testing
  - [ ] 12.1 Test multi-window operations
    - Test simultaneous access to different indexes via Windows A, B, C, and D
    - Test efficient data copying using multiple windows
    - Verify independent operation of all windows
    - _Requirements: 5.2, 5.3, 5.4, 5.5, 5.6, 5.7_
  - [ ] 12.2 Test complete register set
    - Test all active registers in Windows A and B
    - Test reserved registers in Windows C and D
    - Test all shared registers ($C0F0-$C0FF)
    - Verify proper address decoding across full $C000-$C0FF range
    - Test edge cases and boundary conditions between windows and shared space
    - _Requirements: 5.1, 5.2, 5.3, 5.7_
  - [ ] 12.3 Performance and timing validation
    - Measure response times for window register operations
    - Measure response times for shared register operations
    - Verify 1 MHz operation compliance
    - Test sustained throughput with continuous operations
    - Profile timing margins and identify optimization opportunities
    - _Requirements: 5.9, 5.10, 5.11, 5.12_

- [ ] 13. Implement graphics memory organization via indexed interface
  - Pre-configure indexes 16-23 for character table access (8 tables, shared by background and sprites)
  - Pre-configure indexes 32-47 for palette bank access (16 banks, shared resource)
  - Pre-configure indexes 48-51 for nametable access (4 tables for double buffering and scrolling)
  - Pre-configure indexes 52-55 for palette table access (4 tables for double buffering and scrolling)
  - Pre-configure index 56 for sprite OAM data (256 sprites, 8x8 pixels, using character table graphics)
  - Pre-configure index 57 for active frame control register for buffer set selection
  - Test: Verify graphics memory layout and index-based access
  - _Requirements: 3.1, 3.2, 3.3, 3.4, 3.5, 3.6, 3.7, 3.8, 9.2, 9.3, 9.4, 9.5, 9.6, 9.7_

- [ ] 14. Implement USB keyboard system via indexed interface
  - Add build-time configuration for USB Host/Device mode selection
  - Configure TinyUSB stack for selected mode
  - Pre-configure indexes 64-79 for USB keyboard buffer and status
  - Implement circular keyboard buffer accessible via Index 64
  - Add USB status information accessible via Index 65
  - Create IRQ generation for keyboard events
  - Test: Verify USB operation and keyboard data access via indexes
  - _Requirements: 10.1, 10.2, 10.3, 10.4, 10.5, 10.6, 10.7, 10.8, 10.9, 10.10, 10.11, 10.12_

- [ ] 15. Implement Wi-Fi video transmission system
  - Configure Wi-Fi connection and UDP-based communication
  - Create frame data transmission using graphics data from indexed memory (active buffer set)
  - Implement 30 FPS transmission timing (33.33ms intervals)
  - Transmit two nametables and two palette tables per frame based on active frame control register
  - Add dynamic resource updates for character tables and palette banks
  - Create video client communication protocol
  - Test: Verify Wi-Fi connectivity, video data transmission, and double buffering
  - _Requirements: 3.9, 4.1, 4.2, 4.3, 4.4, 4.5, 4.6, 4.7_

- [ ] 16. Implement dual-core coordination and system integration
  - Configure Core 0 for real-time operations (ROM emulation, PIO coordination, bus interface)
  - Configure Core 1 for background processing (video, Wi-Fi, USB, error handling)
  - Implement inter-core communication and shared memory management
  - Add system state management for boot vs indexed interface phases
  - Integrate all subsystems with proper initialization and shutdown sequences
  - Test: Verify complete system operation from boot through indexed interface
  - _Requirements: All requirements - system integration_

- [ ]* 17. Create comprehensive test suite
  - Write unit tests for all bus interface register handlers
  - Create integration tests for dual-window operations
  - Add performance tests for timing validation with logic analyzer
  - Test error handling and edge cases
  - Verify complete boot sequence and indexed interface activation
  - _Requirements: All requirements - validation and verification_